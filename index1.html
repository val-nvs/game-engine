<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Video Cube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        /* WASD Controls */
        #wasd-controls {
            position: absolute;
            bottom: 200px;
            left: 20px;
            user-select: none;
        }
        
        .wasd-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 5px;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }
        
        .wasd-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.8);
        }
        
        .wasd-button:active, .wasd-button.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            transform: scale(0.95);
        }
        
        #wasd-w { top: 0; left: 55px; }
        #wasd-a { top: 55px; left: 0; }
        #wasd-s { top: 55px; left: 55px; }
        #wasd-d { top: 55px; left: 110px; }
        
        /* Playback Controls */
        #playback-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
        }
        
        #playback-controls button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        #playback-controls button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.8);
        }
        
        #toggle-images {
            min-width: 120px;
        }
        
        video {
            display: none;
        }
        
        /* Mobile adjustments */
        @media (max-width: 768px) {
            #wasd-controls {
                bottom: 150px;
            }
            #playback-controls {
                flex-direction: column;
                gap: 5px;
            }
            #playback-controls button {
                padding: 10px 8px;
                font-size: 12px;
            }
            #toggle-images {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="info">
        Drag/Touch to rotate | Scroll/Pinch to zoom | WASD to move<br>
        Loading videos...
    </div>
    
    <!-- WASD Controls -->
    <div id="wasd-controls">
        <div class="wasd-button" id="wasd-w">W</div>
        <div class="wasd-button" id="wasd-a">A</div>
        <div class="wasd-button" id="wasd-s">S</div>
        <div class="wasd-button" id="wasd-d">D</div>
    </div>
    
    <!-- Playback Controls -->
    <div id="playback-controls">
        <button id="play-all">‚ñ∂ Play All</button>
        <button id="pause-all">‚è∏ Pause All</button>
        <button id="sync-all">üîÑ Sync All</button>
        <button id="toggle-images">üñºÔ∏è Toggle Images</button>
    </div>
    
    <!-- Hidden video elements -->
    <video id="video-front" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-back" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-left" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-right" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-top" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-bottom" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-small" loop muted playsinline crossorigin="anonymous"></video>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // Custom shader material for screen blending
        function createScreenBlendMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    videoTexture: { value: null },
                    imageTexture: { value: null },
                    hasImage: { value: 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D videoTexture;
                    uniform sampler2D imageTexture;
                    uniform float hasImage;
                    varying vec2 vUv;
                    
                    vec3 screenBlend(vec3 base, vec3 blend) {
                        return 1.0 - (1.0 - base) * (1.0 - blend);
                    }
                    
                    void main() {
                        vec4 videoColor = texture2D(videoTexture, vUv);
                        
                        if (hasImage > 0.5) {
                            vec4 imageColor = texture2D(imageTexture, vUv);
                            vec3 blended = screenBlend(videoColor.rgb, imageColor.rgb);
                            gl_FragColor = vec4(blended, 1.0);
                        } else {
                            gl_FragColor = videoColor;
                        }
                    }
                `,
                side: THREE.DoubleSide
            });
        }
        
        // Placeholder material before video loads
        const placeholderMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333,
            side: THREE.DoubleSide,
            wireframe: true
        });
        
        // Create cube geometry (6 faces)
        const cubeSize = 6; // 6x6 meters to match real world
        const planeGeometry = new THREE.PlaneGeometry(cubeSize, cubeSize);
        
        // Create all 6 faces with custom shader materials
        const faces = {};
        const faceMaterials = {};
        const faceNames = ['front', 'back', 'left', 'right', 'top', 'bottom'];
        
        faceNames.forEach(faceName => {
            faceMaterials[faceName] = createScreenBlendMaterial();
            faces[faceName] = new THREE.Mesh(planeGeometry, placeholderMaterial.clone());
        });
        
        // Position and rotate faces to form a cube
        const halfSize = cubeSize / 2;
        faces.front.position.set(0, 0, -halfSize);
        
        faces.back.position.set(0, 0, halfSize);
        faces.back.rotation.y = Math.PI;
        
        faces.left.position.set(-halfSize, 0, 0);
        faces.left.rotation.y = Math.PI / 2;
        
        faces.right.position.set(halfSize, 0, 0);
        faces.right.rotation.y = -Math.PI / 2;
        
        faces.top.position.set(0, halfSize, 0);
        faces.top.rotation.x = Math.PI / 2;
        
        faces.bottom.position.set(0, -halfSize, 0);
        faces.bottom.rotation.x = -Math.PI / 2;
        
        // Add all faces to scene
        Object.values(faces).forEach(face => {
            scene.add(face);
            
            // Add edges to make structure visible
            const edgeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                opacity: 0.4, 
                transparent: true 
            });
            const edges = new THREE.EdgesGeometry(planeGeometry);
            const line = new THREE.LineSegments(edges, edgeMaterial);
            face.add(line);
        });
        
        // Add small green video cube (1x1m)
        const smallPlaneGeometry = new THREE.PlaneGeometry(1, 1);
        const smallPlaceholderMaterial = new THREE.MeshBasicMaterial({
            color: 0x006600,
            side: THREE.DoubleSide,
            wireframe: true
        });
        
        const smallFaces = {
            front: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            back: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            left: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            right: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            top: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            bottom: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone())
        };
        
        // Position small cube faces
        smallFaces.front.position.set(1.5, -2.5, -2.0);
        
        smallFaces.back.position.set(1.5, -2.5, -3.0);
        smallFaces.back.rotation.y = Math.PI;
        
        smallFaces.left.position.set(1.0, -2.5, -2.5);
        smallFaces.left.rotation.y = Math.PI / 2;
        
        smallFaces.right.position.set(2.0, -2.5, -2.5);
        smallFaces.right.rotation.y = -Math.PI / 2;
        
        smallFaces.top.position.set(1.5, -2.0, -2.5);
        smallFaces.top.rotation.x = Math.PI / 2;
        
        smallFaces.bottom.position.set(1.5, -3.0, -2.5);
        smallFaces.bottom.rotation.x = -Math.PI / 2;
        
        // Add small faces to scene
        Object.values(smallFaces).forEach(face => {
            scene.add(face);
            
            const smallEdgeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                opacity: 0.6, 
                transparent: true 
            });
            const smallEdges = new THREE.EdgesGeometry(smallPlaneGeometry);
            const smallLine = new THREE.LineSegments(smallEdges, smallEdgeMaterial);
            face.add(smallLine);
        });
        
        // Add white opaque cube
        const whiteCubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const whiteCubeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff
        });
        const whiteCube = new THREE.Mesh(whiteCubeGeometry, whiteCubeMaterial);
        whiteCube.position.set(-2.5, 0, 0);
        scene.add(whiteCube);
        
        // Camera controls
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let rotationX = 0;
        let rotationY = 0;
        let cameraDistance = 2.25;
        
        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let initialPinchDistance = 0;
        
        // Movement variables
        const cameraPosition = new THREE.Vector3(0, 0, 0);
        const moveSpeed = 0.1;
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };
        
        camera.position.set(0, 0, cameraDistance);
        
        // Mouse controls
        renderer.domElement.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;
            
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;
            
            rotationY -= deltaX * 0.01;  // Inverted horizontal rotation
            rotationX += deltaY * 0.01;
            
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        // Touch controls for rotation
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Pinch zoom setup
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                // Single touch - rotate
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                
                rotationY -= deltaX * 0.01;  // Inverted horizontal rotation
                rotationX += deltaY * 0.01;
                
                rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2 && initialPinchDistance > 0) {
                // Pinch zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const delta = (initialPinchDistance - distance) * 0.01;
                cameraDistance += delta;
                cameraDistance = Math.max(0.3, Math.min(5, cameraDistance));
                
                initialPinchDistance = distance;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (e.touches.length === 0) {
                initialPinchDistance = 0;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.007;
            cameraDistance = Math.max(0.3, Math.min(5, cameraDistance));
        }, { passive: false });
        
        // WASD Controls - Keyboard
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
                document.getElementById(`wasd-${key}`).classList.add('active');
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
                document.getElementById(`wasd-${key}`).classList.remove('active');
            }
        });
        
        // WASD Controls - On-screen buttons
        ['w', 'a', 's', 'd'].forEach(key => {
            const button = document.getElementById(`wasd-${key}`);
            
            button.addEventListener('mousedown', () => {
                keys[key] = true;
                button.classList.add('active');
            });
            
            button.addEventListener('mouseup', () => {
                keys[key] = false;
                button.classList.remove('active');
            });
            
            button.addEventListener('mouseleave', () => {
                keys[key] = false;
                button.classList.remove('active');
            });
            
            // Touch support
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                keys[key] = true;
                button.classList.add('active');
            }, { passive: false });
            
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                keys[key] = false;
                button.classList.remove('active');
            }, { passive: false });
        });
        
        // Update camera movement
        function updateMovement() {
            // Forward vector points toward where camera is looking (inward)
            const forward = new THREE.Vector3(
                -Math.sin(rotationY) * Math.cos(rotationX),
                0,
                -Math.cos(rotationY) * Math.cos(rotationX)
            ).normalize();
            
            const right = new THREE.Vector3(
                Math.sin(rotationY + Math.PI/2),
                0,
                Math.cos(rotationY + Math.PI/2)
            ).normalize();
            
            if (keys.w) {
                cameraPosition.addScaledVector(forward, moveSpeed);
            }
            if (keys.s) {
                cameraPosition.addScaledVector(forward, -moveSpeed);
            }
            if (keys.a) {
                cameraPosition.addScaledVector(right, -moveSpeed);
            }
            if (keys.d) {
                cameraPosition.addScaledVector(right, moveSpeed);
            }
        }
        
        // Video management
        const videos = {};
        const videoTextures = {};
        const imageTextures = {};
        let imagesEnabled = true; // Track image overlay state
        
        // Playback controls
        document.getElementById('play-all').addEventListener('click', () => {
            Object.values(videos).forEach(video => {
                if (video.src) {
                    video.play().catch(err => console.log('Play error:', err));
                }
            });
        });
        
        document.getElementById('pause-all').addEventListener('click', () => {
            Object.values(videos).forEach(video => {
                if (video.src) {
                    video.pause();
                }
            });
        });
        
        document.getElementById('sync-all').addEventListener('click', () => {
            Object.values(videos).forEach(video => {
                if (video.src) {
                    video.currentTime = 0;
                    video.play().catch(err => console.log('Sync error:', err));
                }
            });
        });
        
        // Toggle images button
        document.getElementById('toggle-images').addEventListener('click', () => {
            imagesEnabled = !imagesEnabled;
            
            // Update all shader materials
            faceNames.forEach(faceName => {
                const material = faceMaterials[faceName];
                if (material && material.uniforms && imageTextures[faceName]) {
                    material.uniforms.hasImage.value = imagesEnabled ? 1.0 : 0.0;
                    material.needsUpdate = true;
                }
            });
            
            // Update button text to show state
            const button = document.getElementById('toggle-images');
            button.textContent = imagesEnabled ? 'üñºÔ∏è Images ON' : 'üñºÔ∏è Images OFF';
        });
        
        // Function to load image for blending
        function loadImageTexture(faceName) {
            const loader = new THREE.TextureLoader();
            const imagePath = `img-${faceName}.png`;
            
            loader.load(
                imagePath,
                (texture) => {
                    console.log(`${faceName} image loaded`);
                    
                    // Set nearest neighbor filtering for sharp pixels
                    texture.minFilter = THREE.NearestFilter;
                    texture.magFilter = THREE.NearestFilter;
                    texture.generateMipmaps = false;
                    
                    imageTextures[faceName] = texture;
                    
                    // Update the shader material if video is already loaded
                    if (videoTextures[faceName] && faceMaterials[faceName]) {
                        faceMaterials[faceName].uniforms.imageTexture.value = texture;
                        faceMaterials[faceName].uniforms.hasImage.value = imagesEnabled ? 1.0 : 0.0;
                        faceMaterials[faceName].needsUpdate = true;
                    }
                },
                undefined,
                (err) => {
                    console.log(`${faceName} image not found - using video only`);
                }
            );
        }
        
        // Function to load video
        function loadVideo(faceName, source, isFile = false) {
            const video = videos[faceName];
            
            if (isFile) {
                video.src = URL.createObjectURL(source);
            } else {
                video.src = source;
            }
            
            video.load();
            
            video.addEventListener('loadeddata', () => {
                console.log(`${faceName} video loaded`);
                
                // Create video texture
                const videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.NearestFilter;
                videoTexture.magFilter = THREE.NearestFilter;
                videoTexture.format = THREE.RGBFormat;
                
                videoTextures[faceName] = videoTexture;
                
                // Apply to the specific face(s)
                if (faceName === 'small') {
                    // Simple material for small cube
                    const videoMaterial = new THREE.MeshBasicMaterial({
                        map: videoTexture,
                        side: THREE.DoubleSide
                    });
                    Object.values(smallFaces).forEach(face => {
                        face.material = videoMaterial;
                    });
                } else {
                    // Use shader material for main cube faces
                    const shaderMaterial = faceMaterials[faceName];
                    shaderMaterial.uniforms.videoTexture.value = videoTexture;
                    
                    // Check if image is already loaded
                    if (imageTextures[faceName]) {
                        shaderMaterial.uniforms.imageTexture.value = imageTextures[faceName];
                        shaderMaterial.uniforms.hasImage.value = imagesEnabled ? 1.0 : 0.0;
                    }
                    
                    faces[faceName].material = shaderMaterial;
                    shaderMaterial.needsUpdate = true;
                }
                
            }, { once: true });
            
            video.addEventListener('error', (err) => {
                console.log(`${faceName} video not found or error:`, err);
            }, { once: true });
        }
        
        // Setup video objects
        faceNames.forEach(faceName => {
            const video = document.getElementById(`video-${faceName}`);
            videos[faceName] = video;
            // Load corresponding image for blending
            loadImageTexture(faceName);
        });
        
        // Setup small cube video
        const smallVideo = document.getElementById('video-small');
        videos['small'] = smallVideo;
        
        // Load default videos on page load
        function loadDefaultVideos() {
            let loadedCount = 0;
            let errorCount = 0;
            const allVideoNames = [...faceNames, 'small'];
            
            // Load main cube videos
            faceNames.forEach(faceName => {
                const defaultVideoPath = `video-${faceName}.mp4`;
                const video = videos[faceName];
                
                video.addEventListener('loadeddata', () => {
                    loadedCount++;
                    updateLoadingStatus();
                }, { once: true });
                
                video.addEventListener('error', () => {
                    errorCount++;
                    updateLoadingStatus();
                }, { once: true });
                
                loadVideo(faceName, defaultVideoPath, false);
            });
            
            // Load small cube video
            const smallVideo = videos['small'];
            smallVideo.addEventListener('loadeddata', () => {
                loadedCount++;
                updateLoadingStatus();
            }, { once: true });
            
            smallVideo.addEventListener('error', () => {
                errorCount++;
                updateLoadingStatus();
            }, { once: true });
            
            loadVideo('small', 'video-small.mp4', false);
            
            function updateLoadingStatus() {
                const totalProcessed = loadedCount + errorCount;
                if (totalProcessed === allVideoNames.length) {
                    const infoDiv = document.getElementById('info');
                    if (loadedCount > 0) {
                        infoDiv.innerHTML = `Drag/Touch to rotate | Scroll/Pinch to zoom | WASD to move<br>
                            ${loadedCount} video(s) loaded - auto-playing in 5s...`;
                        
                        setTimeout(() => {
                            infoDiv.innerHTML = `Drag/Touch to rotate | Scroll/Pinch to zoom | WASD to move<br>
                                ${loadedCount} video(s) playing`;
                        }, 5000);
                    } else {
                        infoDiv.innerHTML = `Drag/Touch to rotate | Scroll/Pinch to zoom | WASD to move<br>
                            No default videos found`;
                    }
                }
            }
        }
        
        // Load default videos when page loads
        loadDefaultVideos();
        
        // Set initial button state
        document.getElementById('toggle-images').textContent = 'üñºÔ∏è Images ON';
        
        // Auto-play all videos after 5 second delay
        setTimeout(() => {
            console.log('Starting auto-play after 5 second delay...');
            Object.values(videos).forEach(video => {
                if (video.src && video.readyState >= 3) {
                    video.play().catch(err => console.log('Autoplay prevented:', err));
                }
            });
        }, 5000);
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update movement
            updateMovement();
            
            // Update camera position (with movement offset)
            camera.position.x = cameraPosition.x + Math.sin(rotationY) * Math.cos(rotationX) * cameraDistance;
            camera.position.y = cameraPosition.y + Math.sin(rotationX) * cameraDistance;
            camera.position.z = cameraPosition.z + Math.cos(rotationY) * Math.cos(rotationX) * cameraDistance;
            camera.lookAt(cameraPosition.x, cameraPosition.y, cameraPosition.z);
            
            // Update video textures
            Object.values(videoTextures).forEach(texture => {
                if (texture.image && texture.image.readyState === texture.image.HAVE_ENOUGH_DATA) {
                    texture.needsUpdate = true;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>