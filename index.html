<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Video Cube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        video {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <div style="font-weight: bold; margin-bottom: 10px;">Video Cube Controls</div>
        
        <div class="video-upload">
            <label>Front:</label>
            <input type="file" id="video-input-front" accept="video/mp4,video/webm,video/ogg,video/*">
            <span class="status" id="status-front"></span>
        </div>
        
        <div class="video-upload">
            <label>Back:</label>
            <input type="file" id="video-input-back" accept="video/mp4,video/webm,video/ogg,video/*">
            <span class="status" id="status-back"></span>
        </div>
        
        <div class="video-upload">
            <label>Left:</label>
            <input type="file" id="video-input-left" accept="video/mp4,video/webm,video/ogg,video/*">
            <span class="status" id="status-left"></span>
        </div>
        
        <div class="video-upload">
            <label>Right:</label>
            <input type="file" id="video-input-right" accept="video/mp4,video/webm,video/ogg,video/*">
            <span class="status" id="status-right"></span>
        </div>
        
        <div class="video-upload">
            <label>Top:</label>
            <input type="file" id="video-input-top" accept="video/mp4,video/webm,video/ogg,video/*">
            <span class="status" id="status-top"></span>
        </div>
        
        <div class="video-upload">
            <label>Bottom:</label>
            <input type="file" id="video-input-bottom" accept="video/mp4,video/webm,video/ogg,video/*">
            <span class="status" id="status-bottom"></span>
        </div>
        
        <div id="playback-controls">
            <button id="play-all">‚ñ∂ Play All</button>
            <button id="pause-all">‚è∏ Pause All</button>
            <button id="sync-all">üîÑ Sync All</button>
        </div>
    </div>
    
    <div id="info">
        Drag to rotate | Scroll to zoom<br>
        Loading default videos... | Upload custom videos anytime
    </div>
    
    <!-- Hidden video elements -->
    <video id="video-front" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-back" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-left" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-right" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-top" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-bottom" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-small" loop muted playsinline crossorigin="anonymous"></video>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // Placeholder material before video loads
        const placeholderMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333,
            side: THREE.DoubleSide,
            wireframe: true
        });
        
        // Create cube geometry (6 faces)
        const cubeSize = 6; // 6x6 meters to match real world
        const planeGeometry = new THREE.PlaneGeometry(cubeSize, cubeSize);
        
        // Create all 6 faces
        const faces = {
            front: new THREE.Mesh(planeGeometry, placeholderMaterial.clone()),
            back: new THREE.Mesh(planeGeometry, placeholderMaterial.clone()),
            left: new THREE.Mesh(planeGeometry, placeholderMaterial.clone()),
            right: new THREE.Mesh(planeGeometry, placeholderMaterial.clone()),
            top: new THREE.Mesh(planeGeometry, placeholderMaterial.clone()),
            bottom: new THREE.Mesh(planeGeometry, placeholderMaterial.clone())
        };
        
        // Position and rotate faces to form a cube
        const halfSize = cubeSize / 2;
        faces.front.position.set(0, 0, -halfSize);
        
        faces.back.position.set(0, 0, halfSize);
        faces.back.rotation.y = Math.PI;
        
        faces.left.position.set(-halfSize, 0, 0);
        faces.left.rotation.y = Math.PI / 2;
        
        faces.right.position.set(halfSize, 0, 0);
        faces.right.rotation.y = -Math.PI / 2;
        
        faces.top.position.set(0, halfSize, 0);
        faces.top.rotation.x = Math.PI / 2; // Flipped like scoreboard
        
        faces.bottom.position.set(0, -halfSize, 0);
        faces.bottom.rotation.x = -Math.PI / 2; // Flipped like scoreboard
        
        // Add all faces to scene
        Object.values(faces).forEach(face => {
            scene.add(face);
            
            // Add edges to make structure visible
            const edgeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                opacity: 0.4, 
                transparent: true 
            });
            const edges = new THREE.EdgesGeometry(planeGeometry);
            const line = new THREE.LineSegments(edges, edgeMaterial);
            face.add(line);
        });
        
        // Add small green video cube (1x1m) - 6 faces with video-small.mp4
        // Position: touching front wall, bottom wall, 1m from right wall
        // Center at: (1.5, -2.5, -2.5)
        const smallPlaneGeometry = new THREE.PlaneGeometry(1, 1);
        const smallPlaceholderMaterial = new THREE.MeshBasicMaterial({
            color: 0x006600,
            side: THREE.DoubleSide,
            wireframe: true
        });
        
        const smallFaces = {
            front: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            back: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            left: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            right: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            top: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            bottom: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone())
        };
        
        // Position small cube faces around center (1.5, -2.5, -2.5)
        smallFaces.front.position.set(1.5, -2.5, -2.0);
        
        smallFaces.back.position.set(1.5, -2.5, -3.0);
        smallFaces.back.rotation.y = Math.PI;
        
        smallFaces.left.position.set(1.0, -2.5, -2.5);
        smallFaces.left.rotation.y = Math.PI / 2;
        
        smallFaces.right.position.set(2.0, -2.5, -2.5);
        smallFaces.right.rotation.y = -Math.PI / 2;
        
        smallFaces.top.position.set(1.5, -2.0, -2.5);
        smallFaces.top.rotation.x = Math.PI / 2; // Flipped like scoreboard
        
        smallFaces.bottom.position.set(1.5, -3.0, -2.5);
        smallFaces.bottom.rotation.x = -Math.PI / 2; // Flipped like scoreboard
        
        // Add small faces to scene
        Object.values(smallFaces).forEach(face => {
            scene.add(face);
            
            // Add edges for visibility
            const smallEdgeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00, 
                opacity: 0.6, 
                transparent: true 
            });
            const smallEdges = new THREE.EdgesGeometry(smallPlaneGeometry);
            const smallLine = new THREE.LineSegments(smallEdges, smallEdgeMaterial);
            face.add(smallLine);
        });
        
        // Add white opaque cube (1x1m)
        // Position: touching left wall, centered vertically and depth-wise
        const whiteCubeGeometry = new THREE.BoxGeometry(1, 1, 1); // 1x1x1 meters
        const whiteCubeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff // White, opaque
        });
        const whiteCube = new THREE.Mesh(whiteCubeGeometry, whiteCubeMaterial);
        whiteCube.position.set(-2.5, 0, 0); // Your calculation!
        scene.add(whiteCube);
        
        // Camera controls
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let rotationX = 0;
        let rotationY = 0;
        let cameraDistance = 2.25; // Inside the 6x6 cube (cube halfSize is 3)
        
        camera.position.set(0, 0, cameraDistance);
        
        // Mouse controls
        renderer.domElement.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;
            
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;
            
            rotationY += deltaX * 0.01;
            rotationX += deltaY * 0.01;
            
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.007; // Slightly larger increment for bigger cube
            cameraDistance = Math.max(0.3, Math.min(2.7, cameraDistance)); // Keep inside 6x6 cube
        }, { passive: false });
        
        // Video management
        const videos = {};
        const videoTextures = {};
        
        // Function to load video (either from file or URL)
        function loadVideo(faceName, source, isFile = false) {
            const video = videos[faceName];
            
            if (isFile) {
                video.src = URL.createObjectURL(source);
            } else {
                video.src = source;
            }
            
            video.load();
            
            video.addEventListener('loadeddata', () => {
                console.log(`${faceName} video loaded`);
                
                // Create video texture
                const videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.NearestFilter;
                videoTexture.magFilter = THREE.NearestFilter;
                videoTexture.format = THREE.RGBFormat;
                
                videoTextures[faceName] = videoTexture;
                
                // Create video material
                const videoMaterial = new THREE.MeshBasicMaterial({
                    map: videoTexture,
                    side: THREE.DoubleSide
                });
                
                // Apply to the specific face(s)
                if (faceName === 'small') {
                    // Apply to all small cube faces
                    Object.values(smallFaces).forEach(face => {
                        face.material = videoMaterial;
                    });
                } else {
                    // Apply to main cube face
                    faces[faceName].material = videoMaterial;
                }
                
            }, { once: true });
            
            video.addEventListener('error', (err) => {
                console.log(`${faceName} video not found or error:`, err);
            }, { once: true });
        }
        
        // Setup video objects
        const faceNames = ['front', 'back', 'left', 'right', 'top', 'bottom'];
        
        faceNames.forEach(faceName => {
            const video = document.getElementById(`video-${faceName}`);
            videos[faceName] = video;
        });
        
        // Setup small cube video
        const smallVideo = document.getElementById('video-small');
        videos['small'] = smallVideo;
        
        // Load default videos on page load
        function loadDefaultVideos() {
            let loadedCount = 0;
            let errorCount = 0;
            const allVideoNames = [...faceNames, 'small'];
            
            // Load main cube videos
            faceNames.forEach(faceName => {
                const defaultVideoPath = `video-${faceName}.mp4`;
                const video = videos[faceName];
                
                // Add one-time listeners to track loading progress
                video.addEventListener('loadeddata', () => {
                    loadedCount++;
                    updateLoadingStatus();
                }, { once: true });
                
                video.addEventListener('error', () => {
                    errorCount++;
                    updateLoadingStatus();
                }, { once: true });
                
                loadVideo(faceName, defaultVideoPath, false);
            });
            
            // Load small cube video
            const smallVideo = videos['small'];
            smallVideo.addEventListener('loadeddata', () => {
                loadedCount++;
                updateLoadingStatus();
            }, { once: true });
            
            smallVideo.addEventListener('error', () => {
                errorCount++;
                updateLoadingStatus();
            }, { once: true });
            
            loadVideo('small', 'video-small.mp4', false);
            
            function updateLoadingStatus() {
                const totalProcessed = loadedCount + errorCount;
                if (totalProcessed === allVideoNames.length) {
                    const infoDiv = document.getElementById('info');
                    if (loadedCount > 0) {
                        infoDiv.innerHTML = `Drag to rotate | Scroll to zoom<br>
                            ${loadedCount} video(s) loaded - auto-playing in 5s...`;
                        
                        // Update message after 5 seconds
                        setTimeout(() => {
                            infoDiv.innerHTML = `Drag to rotate | Scroll to zoom<br>
                                ${loadedCount} video(s) playing`;
                        }, 5000);
                    } else {
                        infoDiv.innerHTML = `Drag to rotate | Scroll to zoom<br>
                            No default videos found`;
                    }
                }
            }
        }
        
        // Load default videos when page loads
        loadDefaultVideos();
        
        // Auto-play all videos after 5 second delay
        setTimeout(() => {
            console.log('Starting auto-play after 5 second delay...');
            Object.values(videos).forEach(video => {
                if (video.src && video.readyState >= 3) { // HAVE_FUTURE_DATA or better
                    video.play().catch(err => console.log('Autoplay prevented:', err));
                }
            });
        }, 5000); // 5 second delay
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update camera position
            camera.position.x = Math.sin(rotationY) * Math.cos(rotationX) * cameraDistance;
            camera.position.y = Math.sin(rotationX) * cameraDistance;
            camera.position.z = Math.cos(rotationY) * Math.cos(rotationX) * cameraDistance;
            camera.lookAt(0, 0, 0);
            
            // Update video textures
            Object.values(videoTextures).forEach(texture => {
                if (texture.image && texture.image.readyState === texture.image.HAVE_ENOUGH_DATA) {
                    texture.needsUpdate = true;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>