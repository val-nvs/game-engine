<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Video Cube</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        #wasd-controls {
            position: absolute;
            bottom: 200px;
            left: 20px;
        }
        
        .wasd-button {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid white;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            border-radius: 3px;
        }
        
        #wasd-w { top: 0; left: 55px; }
        #wasd-a { top: 55px; left: 0; }
        #wasd-s { top: 55px; left: 55px; }
        #wasd-d { top: 55px; left: 110px; }
        
        #playback-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
        }
        
        #playback-controls button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid white;
            color: white;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 3px;
        }
        
        video {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="info">
        Drag/Touch to rotate | Scroll/Pinch to zoom | WASD to move<br>
        Loading videos...
    </div>
    
    <div id="wasd-controls">
        <div class="wasd-button" id="wasd-w">W</div>
        <div class="wasd-button" id="wasd-a">A</div>
        <div class="wasd-button" id="wasd-s">S</div>
        <div class="wasd-button" id="wasd-d">D</div>
    </div>
    
    <div id="playback-controls">
        <button id="play-all">Play All</button>
        <button id="pause-all">Pause All</button>
        <button id="sync-all">Sync All</button>
    </div>
    
    <video id="video-front" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-back" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-left" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-right" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-top" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-bottom" loop muted playsinline crossorigin="anonymous"></video>
    <video id="video-small" loop muted playsinline crossorigin="anonymous"></video>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambientLight);
        
        const placeholderMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333,
            side: THREE.DoubleSide
        });
        
        const cubeSize = 6;
        const planeGeometry = new THREE.PlaneGeometry(cubeSize, cubeSize);
        
        const faces = {};
        const faceNames = ['front', 'back', 'left', 'right', 'top', 'bottom'];
        
        faceNames.forEach(faceName => {
            faces[faceName] = new THREE.Mesh(planeGeometry, placeholderMaterial.clone());
        });
        
        const halfSize = cubeSize / 2;
        faces.front.position.set(0, 0, -halfSize);
        
        faces.back.position.set(0, 0, halfSize);
        faces.back.rotation.y = Math.PI;
        
        faces.left.position.set(-halfSize, 0, 0);
        faces.left.rotation.y = Math.PI / 2;
        
        faces.right.position.set(halfSize, 0, 0);
        faces.right.rotation.y = -Math.PI / 2;
        
        faces.top.position.set(0, halfSize, 0);
        faces.top.rotation.x = Math.PI / 2;
        
        faces.bottom.position.set(0, -halfSize, 0);
        faces.bottom.rotation.x = -Math.PI / 2;
        
        Object.values(faces).forEach(face => {
            scene.add(face);
        });
        
        const smallPlaneGeometry = new THREE.PlaneGeometry(1, 1);
        const smallPlaceholderMaterial = new THREE.MeshBasicMaterial({
            color: 0x006600,
            side: THREE.DoubleSide
        });
        
        const smallFaces = {
            front: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            back: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            left: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            right: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            top: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone()),
            bottom: new THREE.Mesh(smallPlaneGeometry, smallPlaceholderMaterial.clone())
        };
        
        smallFaces.front.position.set(1.5, -2.5, -2.0);
        smallFaces.back.position.set(1.5, -2.5, -3.0);
        smallFaces.back.rotation.y = Math.PI;
        smallFaces.left.position.set(1.0, -2.5, -2.5);
        smallFaces.left.rotation.y = Math.PI / 2;
        smallFaces.right.position.set(2.0, -2.5, -2.5);
        smallFaces.right.rotation.y = -Math.PI / 2;
        smallFaces.top.position.set(1.5, -2.0, -2.5);
        smallFaces.top.rotation.x = Math.PI / 2;
        smallFaces.bottom.position.set(1.5, -3.0, -2.5);
        smallFaces.bottom.rotation.x = -Math.PI / 2;
        
        Object.values(smallFaces).forEach(face => {
            scene.add(face);
        });
        
        const whiteCubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const whiteCubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const whiteCube = new THREE.Mesh(whiteCubeGeometry, whiteCubeMaterial);
        whiteCube.position.set(-2.5, 0, 0);
        scene.add(whiteCube);
        
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let rotationX = 0;
        let rotationY = 0;
        let cameraDistance = 2.25;
        
        let touchStartX = 0;
        let touchStartY = 0;
        let initialPinchDistance = 0;
        
        const cameraPosition = new THREE.Vector3(0, 0, 0);
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };
        
        camera.position.set(0, 0, cameraDistance);
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;
            
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;
            
            rotationY -= deltaX * 0.01;
            rotationX += deltaY * 0.01;
            
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                
                rotationY -= deltaX * 0.01;
                rotationX += deltaY * 0.01;
                
                rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            } else if (e.touches.length === 2 && initialPinchDistance > 0) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const delta = (initialPinchDistance - distance) * 0.01;
                cameraDistance += delta;
                cameraDistance = Math.max(0.3, Math.min(5, cameraDistance));
                
                initialPinchDistance = distance;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (e.touches.length === 0) {
                initialPinchDistance = 0;
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.007;
            cameraDistance = Math.max(0.3, Math.min(5, cameraDistance));
        }, { passive: false });
        
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
            }
        });
        
        ['w', 'a', 's', 'd'].forEach(key => {
            const button = document.getElementById(`wasd-${key}`);
            
            button.addEventListener('mousedown', () => {
                keys[key] = true;
            });
            
            button.addEventListener('mouseup', () => {
                keys[key] = false;
            });
            
            button.addEventListener('mouseleave', () => {
                keys[key] = false;
            });
            
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                keys[key] = true;
            }, { passive: false });
            
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                keys[key] = false;
            }, { passive: false });
        });
        
        function updateMovement() {
            const forward = new THREE.Vector3(
                -Math.sin(rotationY) * Math.cos(rotationX),
                0,
                -Math.cos(rotationY) * Math.cos(rotationX)
            ).normalize();
            
            const right = new THREE.Vector3(
                Math.sin(rotationY + Math.PI/2),
                0,
                Math.cos(rotationY + Math.PI/2)
            ).normalize();
            
            if (keys.w) {
                cameraPosition.addScaledVector(forward, moveSpeed);
            }
            if (keys.s) {
                cameraPosition.addScaledVector(forward, -moveSpeed);
            }
            if (keys.a) {
                cameraPosition.addScaledVector(right, -moveSpeed);
            }
            if (keys.d) {
                cameraPosition.addScaledVector(right, moveSpeed);
            }
        }
        
        const videos = {};
        const videoTextures = {};
        
        document.getElementById('play-all').addEventListener('click', () => {
            Object.values(videos).forEach(video => {
                if (video.src) {
                    video.play().catch(err => console.log('Play error:', err));
                }
            });
        });
        
        document.getElementById('pause-all').addEventListener('click', () => {
            Object.values(videos).forEach(video => {
                if (video.src) {
                    video.pause();
                }
            });
        });
        
        document.getElementById('sync-all').addEventListener('click', () => {
            Object.values(videos).forEach(video => {
                if (video.src) {
                    video.currentTime = 0;
                    video.play().catch(err => console.log('Sync error:', err));
                }
            });
        });
        
        function loadVideo(faceName, source, isFile = false) {
            const video = videos[faceName];
            
            if (isFile) {
                video.src = URL.createObjectURL(source);
            } else {
                video.src = source;
            }
            
            video.load();
            
            video.addEventListener('loadeddata', () => {
                console.log(`${faceName} video loaded`);
                
                const videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.NearestFilter;
                videoTexture.magFilter = THREE.NearestFilter;
                videoTexture.format = THREE.RGBFormat;
                
                videoTextures[faceName] = videoTexture;
                
                if (faceName === 'small') {
                    const videoMaterial = new THREE.MeshBasicMaterial({
                        map: videoTexture,
                        side: THREE.DoubleSide
                    });
                    Object.values(smallFaces).forEach(face => {
                        face.material = videoMaterial;
                    });
                } else {
                    const videoMaterial = new THREE.MeshBasicMaterial({
                        map: videoTexture,
                        side: THREE.DoubleSide
                    });
                    faces[faceName].material = videoMaterial;
                }
                
            }, { once: true });
            
            video.addEventListener('error', (err) => {
                console.log(`${faceName} video not found or error:`, err);
            }, { once: true });
        }
        
        faceNames.forEach(faceName => {
            const video = document.getElementById(`video-${faceName}`);
            videos[faceName] = video;
        });
        
        const smallVideo = document.getElementById('video-small');
        videos['small'] = smallVideo;
        
        function loadDefaultVideos() {
            let loadedCount = 0;
            let errorCount = 0;
            const allVideoNames = [...faceNames, 'small'];
            
            faceNames.forEach(faceName => {
                const defaultVideoPath = `video-${faceName}.mp4`;
                const video = videos[faceName];
                
                video.addEventListener('loadeddata', () => {
                    loadedCount++;
                    updateLoadingStatus();
                }, { once: true });
                
                video.addEventListener('error', () => {
                    errorCount++;
                    updateLoadingStatus();
                }, { once: true });
                
                loadVideo(faceName, defaultVideoPath, false);
            });
            
            const smallVideo = videos['small'];
            smallVideo.addEventListener('loadeddata', () => {
                loadedCount++;
                updateLoadingStatus();
            }, { once: true });
            
            smallVideo.addEventListener('error', () => {
                errorCount++;
                updateLoadingStatus();
            }, { once: true });
            
            loadVideo('small', 'video-small.mp4', false);
            
            function updateLoadingStatus() {
                const totalProcessed = loadedCount + errorCount;
                if (totalProcessed === allVideoNames.length) {
                    const infoDiv = document.getElementById('info');
                    if (loadedCount > 0) {
                        infoDiv.innerHTML = `Drag/Touch to rotate | Scroll/Pinch to zoom | WASD to move<br>
                            ${loadedCount} video(s) loaded - auto-playing in 5s...`;
                        
                        setTimeout(() => {
                            infoDiv.innerHTML = `Drag/Touch to rotate | Scroll/Pinch to zoom | WASD to move<br>
                                ${loadedCount} video(s) playing`;
                        }, 5000);
                    } else {
                        infoDiv.innerHTML = `Drag/Touch to rotate | Scroll/Pinch to zoom | WASD to move<br>
                            No default videos found`;
                    }
                }
            }
        }
        
        loadDefaultVideos();
        
        setTimeout(() => {
            console.log('Starting auto-play after 5 second delay...');
            Object.values(videos).forEach(video => {
                if (video.src && video.readyState >= 3) {
                    video.play().catch(err => console.log('Autoplay prevented:', err));
                }
            });
        }, 5000);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        function animate() {
            requestAnimationFrame(animate);
            
            updateMovement();
            
            camera.position.x = cameraPosition.x + Math.sin(rotationY) * Math.cos(rotationX) * cameraDistance;
            camera.position.y = cameraPosition.y + Math.sin(rotationX) * cameraDistance;
            camera.position.z = cameraPosition.z + Math.cos(rotationY) * Math.cos(rotationX) * cameraDistance;
            camera.lookAt(cameraPosition.x, cameraPosition.y, cameraPosition.z);
            
            Object.values(videoTextures).forEach(texture => {
                if (texture.image && texture.image.readyState === texture.image.HAVE_ENOUGH_DATA) {
                    texture.needsUpdate = true;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>